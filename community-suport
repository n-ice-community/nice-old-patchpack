# HG changeset patch
# Parent 31b2e39e4cc4dc8109a6a8ed19c207dad31eb84f
# Parent  6e0ffe3d21618befbf600310c550efe7b30d8787

diff -r 6e0ffe3d2161 source.list
--- a/source.list	Mon Mar 30 14:39:39 2015 +0100
+++ b/source.list	Thu Apr 02 21:37:45 2015 +0100
@@ -54,6 +54,7 @@
 misc.cpp
 mixer.cpp
 music.cpp
+nc_csettings.cpp
 network/network.cpp
 network/network_admin.cpp
 network/network_client.cpp
@@ -240,6 +241,8 @@
 map_func.h
 map_type.h
 mixer.h
+nc_csettings.h
+nc_receiver.h
 network/network.h
 network/network_admin.h
 network/network_base.h
diff -r 6e0ffe3d2161 src/fileio.cpp
--- a/src/fileio.cpp	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/fileio.cpp	Thu Apr 02 21:37:45 2015 +0100
@@ -293,6 +293,7 @@
 	"game" PATHSEP,
 	"game" PATHSEP "library" PATHSEP,
 	"screenshot" PATHSEP,
+	"community" PATHSEP,
 };
 assert_compile(lengthof(_subdirs) == NUM_SUBDIRS);
 
@@ -1261,6 +1262,10 @@
 	_hotkeys_file = str_fmt("%shotkeys.cfg", config_dir);
 	extern char *_windows_file;
 	_windows_file = str_fmt("%swindows.cfg", config_dir);
+	
+	extern char *_community_dir;
+	_community_dir = str_fmt("%s%s", config_dir, _subdirs[COMMUNITY_DIR]); // TODO find better solution
+	
 
 #if defined(WITH_XDG_BASEDIR) && defined(WITH_PERSONAL_DIR)
 	if (config_dir == config_home) {
@@ -1283,7 +1288,7 @@
 	DEBUG(misc, 3, "%s found as personal directory", _personal_dir);
 
 	static const Subdirectory default_subdirs[] = {
-		SAVE_DIR, AUTOSAVE_DIR, SCENARIO_DIR, HEIGHTMAP_DIR, BASESET_DIR, NEWGRF_DIR, AI_DIR, AI_LIBRARY_DIR, GAME_DIR, GAME_LIBRARY_DIR, SCREENSHOT_DIR
+		SAVE_DIR, AUTOSAVE_DIR, SCENARIO_DIR, HEIGHTMAP_DIR, BASESET_DIR, NEWGRF_DIR, AI_DIR, AI_LIBRARY_DIR, GAME_DIR, GAME_LIBRARY_DIR, SCREENSHOT_DIR, COMMUNITY_DIR
 	};
 
 	for (uint i = 0; i < lengthof(default_subdirs); i++) {
diff -r 6e0ffe3d2161 src/fileio_type.h
--- a/src/fileio_type.h	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/fileio_type.h	Thu Apr 02 21:37:45 2015 +0100
@@ -33,6 +33,7 @@
 	GAME_DIR,      ///< Subdirectory for all game scripts
 	GAME_LIBRARY_DIR, ///< Subdirectory for all GS libraries
 	SCREENSHOT_DIR,   ///< Subdirectory for all screenshots
+	COMMUNITY_DIR,    ///< Subdirectory for all community files
 	NUM_SUBDIRS,   ///< Number of subdirectories
 	NO_DIRECTORY,  ///< A path without any base directory
 };
diff -r 6e0ffe3d2161 src/ini_load.cpp
--- a/src/ini_load.cpp	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/ini_load.cpp	Thu Apr 02 21:37:45 2015 +0100
@@ -323,3 +323,120 @@
 	fclose(in);
 }
 
+/**
+ * Load the Ini file's data from a string
+ * @param text the string with ini format
+ * @pre nothing has been loaded yet.
+ */
+void IniLoadFile::LoadFromString(std::string text)
+{
+	assert(this->last_group == &this->group);
+
+	char buffer[1024];
+	IniGroup *group = NULL;
+
+	char *comment = NULL;
+	uint comment_size = 0;
+	uint comment_alloc = 0;
+
+	if (text.empty()) return;
+
+	uint pos = 0;
+	size_t pos2 = 0;
+	/* for each line in the string */
+	while (pos <= text.length() && pos2 != std::string::npos) {
+		strecpy(buffer,text.substr(pos, ((pos2 = text.find('\n',pos+1)) == std::string::npos ? text.length() : pos2)-pos).c_str(),lastof(buffer));
+		pos = pos2+1;
+		char c, *s;
+		/* trim whitespace from the left side */
+		for (s = buffer; *s == ' ' || *s == '\t'; s++) {}
+
+		/* trim whitespace from right side. */
+		char *e = s + strlen(s);
+		while (e > s && ((c = e[-1]) == '\n' || c == '\r' || c == ' ' || c == '\t')) e--;
+		*e = '\0';
+
+		/* Skip comments and empty lines outside IGT_SEQUENCE groups. */
+		if ((group == NULL || group->type != IGT_SEQUENCE) && (*s == '#' || *s == ';' || *s == '\0')) {
+			uint ns = comment_size + (e - s + 1);
+			uint a = comment_alloc;
+			/* add to comment */
+			if (ns > a) {
+				a = max(a, 128U);
+				do a *= 2; while (a < ns);
+				comment = ReallocT(comment, comment_alloc = a);
+			}
+			uint pos = comment_size;
+			comment_size += (e - s + 1);
+			comment[pos + e - s] = '\n'; // comment newline
+			memcpy(comment + pos, s, e - s); // copy comment contents
+			continue;
+		}
+
+		/* it's a group? */
+		if (s[0] == '[') {
+			if (e[-1] != ']') {
+				this->ReportFileError("ini: invalid group name '", buffer, "'");
+			} else {
+				e--;
+			}
+			s++; // skip [
+			group = new IniGroup(this, s, e - 1);
+			if (comment_size != 0) {
+				group->comment = stredup(comment, comment + comment_size - 1);
+				comment_size = 0;
+			}
+		} else if (group != NULL) {
+			if (group->type == IGT_SEQUENCE) {
+				/* A sequence group, use the line as item name without further interpretation. */
+				IniItem *item = new IniItem(group, buffer, e - 1);
+				if (comment_size) {
+					item->comment = stredup(comment, comment + comment_size - 1);
+					comment_size = 0;
+				}
+				continue;
+			}
+			char *t;
+			/* find end of keyname */
+			if (*s == '\"') {
+				s++;
+				for (t = s; *t != '\0' && *t != '\"'; t++) {}
+				if (*t == '\"') *t = ' ';
+			} else {
+				for (t = s; *t != '\0' && *t != '=' && *t != '\t' && *t != ' '; t++) {}
+			}
+
+			/* it's an item in an existing group */
+			IniItem *item = new IniItem(group, s, t - 1);
+			if (comment_size != 0) {
+				item->comment = stredup(comment, comment + comment_size - 1);
+				comment_size = 0;
+			}
+
+			/* find start of parameter */
+			while (*t == '=' || *t == ' ' || *t == '\t') t++;
+
+			bool quoted = (*t == '\"');
+			/* remove starting quotation marks */
+			if (*t == '\"') t++;
+			/* remove ending quotation marks */
+			e = t + strlen(t);
+			if (e > t && e[-1] == '\"') e--;
+			*e = '\0';
+
+			/* If the value was not quoted and empty, it must be NULL */
+			item->value = (!quoted && e == t) ? NULL : stredup(t);
+			if (item->value != NULL) str_validate(item->value, item->value + strlen(item->value));
+		} else {
+			/* it's an orphan item */
+			this->ReportFileError("ini: '", buffer, "' outside of group");
+		}
+	}
+
+	if (comment_size > 0) {
+		this->comment = stredup(comment, comment + comment_size - 1);
+		comment_size = 0;
+	}
+
+	free(comment);
+}
diff -r 6e0ffe3d2161 src/ini_type.h
--- a/src/ini_type.h	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/ini_type.h	Thu Apr 02 21:37:45 2015 +0100
@@ -12,6 +12,7 @@
 #ifndef INI_TYPE_H
 #define INI_TYPE_H
 
+#include <string>
 #include "fileio_type.h"
 
 /** Types of groups */
@@ -65,6 +66,7 @@
 	void RemoveGroup(const char *name);
 
 	void LoadFromDisk(const char *filename, Subdirectory subdir);
+	void LoadFromString(std::string text);
 
 	/**
 	 * Open the INI file.
diff -r 6e0ffe3d2161 src/intro_gui.cpp
--- a/src/intro_gui.cpp	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/intro_gui.cpp	Thu Apr 02 21:37:45 2015 +0100
@@ -9,6 +9,8 @@
 
 /** @file intro_gui.cpp The main menu GUI. */
 
+#include "nc_csettings.h"
+
 #include "stdafx.h"
 #include "error.h"
 #include "gui.h"
diff -r 6e0ffe3d2161 src/nc_csettings.cpp
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/nc_csettings.cpp	Thu Apr 02 21:37:45 2015 +0100
@@ -0,0 +1,619 @@
+#include "nc_csettings.h"
+#include "network/network_content.h"
+#include "fileio_func.h"
+#include "safeguards.h"
+
+Server::Server() : display_name(NULL), ipv4(NULL), ipv6(NULL), port(0), uid(0)
+{
+}
+
+char* _community_dir;
+
+CSettings& CSettings::get()
+{
+	static CSettings instance;
+	return instance;
+}
+
+CSettings::CSettings()
+{
+	community_file = str_fmt("%scommunities.cfg", _community_dir);
+	this->selected = 0;
+	if(FileExists(community_file)) // Load from file
+		LoadCommunities();
+}
+
+void CSettings::CheckIntegrity()
+{
+	for(uint i = 0; i < community_list.Length();i++)
+		community_list[i]->CheckIntegrity();
+}
+void CSettings::AddCommunity(const char* name, const char* link)
+{
+	for(uint i = 0; i < community_list.Length() ; i++)
+	{
+		if(strcmp(community_list[i]->group_name,name)==0)
+			return;
+	}
+	Community* temp = new Community(this);
+	temp->Load(name,link);
+	if(community_list.Length() == 1)
+		this->selected = 1;
+	*community_list.Append() = temp;
+	this->SaveCommunities();
+}
+void CSettings::LoadCommunities()
+{
+	IniFile *ini = new IniFile();
+	ini->LoadFromDisk(community_file, BASE_DIR);
+	
+	IniGroup* cur = ini->group;
+	while(&cur != ini->last_group && cur != NULL)// TODO Verify if it is correct
+	{
+		Community* temp = new Community(this);
+		if(temp->Load(cur,false))
+			this->selected = community_list.Length();
+		*community_list.Append() = temp;
+		cur = cur->next;
+	}
+	delete ini;
+}
+
+void CSettings::SaveCommunities()
+{
+	IniFile *ini = new IniFile();
+	ini->LoadFromDisk(community_file, BASE_DIR);
+
+	for(uint i = 0; i < community_list.Length() ; i++)
+	{
+		community_list[i]->Save(ini,this->selected == i);
+	}
+	ini->SaveToDisk(community_file);
+	RegistUpdate();
+	delete ini;
+}
+
+int CSettings::Size()
+{
+	return community_list.Length();
+}
+void CSettings::RegistToWait(void (*thereWasAnUpdate)(void))
+{
+	this->thereWasAnUpdate = thereWasAnUpdate;
+}
+void CSettings::RegistUpdate()
+{
+	if(thereWasAnUpdate) thereWasAnUpdate();
+}
+Community *CSettings::GetSelected()
+{
+	CheckIntegrity();
+	return community_list.Length() == 0 ? NULL : community_list[selected];
+}
+uint CSettings::Selected()
+{
+	return this->selected;
+}
+void CSettings::SetSelected(uint i)
+{
+	this->selected = i <= (community_list.Length()-1) ? i : (community_list.Length()-1);
+	this->SaveCommunities();
+}
+char *CSettings::GetCommunityName(int i)
+{
+	return community_list[i]->display_name;
+}
+Community::Community(CSettings* s) : _instance(NULL), linklist_url(NULL), serverlist_url(NULL),servergrouplist_url(NULL),adminlist_url(NULL),modified(0),out_of_sync(false),server_list(NULL),servergroup_list(NULL),display_name(NULL),group_name(NULL),username(NULL),password(NULL),admin(NULL),adminpass(NULL)
+{
+	this->_instance = s;
+}
+void Community::CheckIntegrity()
+{
+	// TODO For now assume it was moddified every 5 min
+	// TODO Later implement If-Modified-Since: HTTP Request
+	if((difftime(std::time(nullptr),this->modified) >= 300 /*5min*/ ))
+	{
+		if(!out_of_sync)
+			ReceiveModified(true);
+	}
+	if(server_list != NULL) server_list->CheckIntegrity();
+	if(servergroup_list != NULL) servergroup_list->CheckIntegrity();
+}
+
+void Community::ReceiveModified(bool mod)
+{
+	if(mod)
+	{
+		new SimpleTxtDownloader(this->linklist_url , this);
+		this->out_of_sync = true;
+	}	
+}
+
+void Community::DataReceived(std::string s)
+{
+	IniFile* ini = new IniFile();
+	ini->LoadFromString(s);
+	IniGroup* cur = ini->group;
+	
+	this->Load(cur,true);
+	this->out_of_sync = false;
+	_instance->SaveCommunities();
+	delete ini;
+}
+void Community::Failed()
+{
+}
+
+bool Community::isOutOfSync()
+{
+	return out_of_sync;
+}
+
+const char* Community::GetName()
+{
+	return display_name;
+}
+void Community::Load(const char* name, const char* link)
+{
+	this->display_name = this->group_name = stredup(name,NULL);
+	this->linklist_url = stredup(link,NULL);
+}
+bool Community::Load(IniGroup* group,bool update)
+{
+	bool result = false; 
+	IniItem* item = group->GetItem("linklist",false);
+	this->group_name = stredup(group->name,NULL);
+	if(item == NULL)
+	{
+		printf("Linked list not found");
+		//Error . Invalid
+		return false;
+	}
+	this->linklist_url = stredup(item->value,NULL);
+	
+	this->display_name = (item = group->GetItem("display_name",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	if((item =group->GetItem("selected",false)) != NULL && strcmp(item->value,"true") == 0)
+		result = true;
+	item = group->GetItem("serverlist",false);
+	
+	this->serverlist_url = (item = group->GetItem("serverlist",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	this->servergrouplist_url = (item = group->GetItem("servergroup",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	this->adminlist_url = (item = group->GetItem("adminlist",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	if((item = group->GetItem("modified",false)) == NULL)
+		if(update)
+			this->modified = std::time(nullptr);
+		else
+			this->modified = 0;
+	else
+		this->modified = static_cast<time_t>(atol(item->value));
+	
+	this->username = (item = group->GetItem("username",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	this->password = (item = group->GetItem("password",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	this->admin = (item = group->GetItem("admin",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+	this->adminpass = (item = group->GetItem("adminpass",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+
+	return result;
+}
+
+void Community::Save(IniFile* ini, bool selected)
+{
+	IniGroup* group = ini->GetGroup(this->group_name,0,true);
+	if(this->display_name != NULL) group->GetItem("display_name",true)->SetValue(this->display_name);
+	if(this->linklist_url != NULL) group->GetItem("linklist",true)->SetValue(this->linklist_url);
+	if(this->serverlist_url != NULL) group->GetItem("serverlist",true)->SetValue(this->serverlist_url);
+	if(this->servergrouplist_url != NULL) group->GetItem("servergroup",true)->SetValue(this->servergrouplist_url);
+	if(this->adminlist_url != NULL) group->GetItem("adminlist",true)->SetValue(this->adminlist_url);
+	if(this->username != NULL) group->GetItem("username",true)->SetValue(this->username);
+	if(this->password != NULL) group->GetItem("password",true)->SetValue(this->password);
+	if(this->admin != NULL) group->GetItem("admin",true)->SetValue(this->admin);
+	if(this->adminpass != NULL) group->GetItem("adminpass",true)->SetValue(this->adminpass);
+
+	char temp[32];
+	seprintf(temp, lastof(temp),"%ld",this->modified);
+	group->GetItem("modified",true)->SetValue(temp);
+	group->GetItem("selected",true)->SetValue( selected ? "true": "false");
+}
+
+long int Community::LastModified()
+{
+	return modified;
+}
+ServerGroupList* Community::GetGroups()
+{
+	return servergroup_list;
+}
+void Community::SetGroup(int i)
+{
+	this->servergroup_list->SetSelected(i);
+}
+ServerList* Community::GetServerList() 
+{
+	if(server_list == NULL && serverlist_url != NULL)
+	{
+		server_list = new ServerList(str_fmt("%s%s_serverlist.cfg",_community_dir,this->group_name),this->serverlist_url);
+		server_list->Load(NULL,false);
+	}
+	return  serverlist_url == NULL ? NULL : server_list;
+}
+ServerGroup* Community::GetServerGroup()
+{
+	if(servergroup_list == NULL && servergrouplist_url != NULL)
+	{
+		servergroup_list = new ServerGroupList(str_fmt("%s%s_servergroup.cfg",_community_dir,this->group_name),this->servergrouplist_url);
+		servergroup_list->Load(NULL,false);
+	}
+	return this->servergroup_list == NULL ? NULL: this->servergroup_list->GetSelected();
+}
+
+ServerList::ServerList(char *file,char *link) : link(NULL), file(NULL), modified(0), out_of_sync(false)
+{
+	this->file = file;
+	this->link = link;
+}
+void ServerList::CheckIntegrity()
+{
+	// TODO For now assume it was moddified every 5 min
+	// TODO Later implement If-Modified-Since: HTTP Request
+	this->isOutOfSync();
+	if((difftime(std::time(nullptr),this->modified) >= 300 /*5min*/ ))
+	{
+		if(!out_of_sync)
+			ReceiveModified(true);
+	}
+}
+
+void ServerList::ReceiveModified(bool mod)
+{
+	if(mod)
+	{
+		new SimpleTxtDownloader(this->link, this);
+		this->out_of_sync = true;
+	}	
+}
+
+void ServerList::DataReceived(std::string s)
+{
+	IniFile* ini = new IniFile();
+	ini->LoadFromString(s);
+	this->Load(ini,true);
+	this->Save();
+	this->out_of_sync = false;
+	delete ini;
+}
+void ServerList::Failed()
+{
+}
+
+bool ServerList::isOutOfSync()
+{
+	return this->out_of_sync;
+}
+
+void ServerList::Load(IniFile* ini,bool update)
+{
+	data.Clear();
+	if(!update)
+	{
+		ini = new IniFile();
+		ini->LoadFromDisk(file,BASE_DIR);
+	}else
+	{
+		this->modified = std::time(nullptr);
+	}
+	IniGroup* group = ini->group;
+	IniItem* item;
+	for(;&group != ini->last_group && group != NULL;group = group->next)
+	{
+		if(strcmp(group->name,"details") == 0)
+		{
+			if((item = group->GetItem("modified",false)) == NULL)
+				this->modified = 0;
+			else
+				this->modified = static_cast<time_t>(atol(item->value));
+			continue;
+		}
+		Server* temp = new Server();
+		temp->display_name =(item = group->GetItem("display_name",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		temp->ipv4 = (item = group->GetItem("ipv4",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		temp->ipv6 = (item = group->GetItem("ipv6",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		temp->port = (item = group->GetItem("port",false)) == NULL || item->value == NULL ? 0 : atoi(item->value);
+		temp->uid = (item = group->GetItem("uid",false)) == NULL || item->value == NULL ? 0 : atoi(item->value);
+		*this->data.Append() = temp;
+	}
+	delete ini;	
+}
+
+void ServerList::Save()
+{
+	IniFile* ini = new IniFile();
+	IniGroup* group = ini->GetGroup("details",0,true);
+	char temp[32];
+	seprintf(temp, lastof(temp),"%ld",this->modified);
+	group->GetItem("modified",true)->SetValue(temp);
+	for(uint i = 0; i < data.Length(); i++)
+	{
+		group = ini->GetGroup(data[i]->display_name,0,true);
+		if(data[i]->display_name != NULL) group->GetItem("display_name",true)->SetValue(data[i]->display_name);
+		if(data[i]->ipv4 != NULL) group->GetItem("ipv4",true)->SetValue(data[i]->ipv4);
+		if(data[i]->ipv6 != NULL) group->GetItem("ipv6",true)->SetValue(data[i]->ipv6);
+		char temp[5];
+		seprintf(temp,lastof(temp),"%d",data[i]->port);
+		group->GetItem("port",true)->SetValue(temp);
+		seprintf(temp,lastof(temp),"%d",data[i]->uid);
+		group->GetItem("uid",true)->SetValue(temp);
+	}
+	ini->SaveToDisk(file);
+	CSettings::get().RegistUpdate();
+}
+
+Server *ServerList::Get(uint i)
+{
+	return i <= data.Length()? data[i] : NULL;
+}
+Server *ServerList::GetByUid(uint u)
+{
+	for(uint i = 0; i < data.Length(); i++)
+	{
+		if(u == data[i]->uid)
+			return this->Get(i);
+	}	
+	return NULL;
+}
+uint ServerList::GetPosByUid(uint u)
+{
+	for(uint i = 0; i < data.Length(); i++)
+	{
+		if(u == data[i]->uid)
+			return i;
+	}	
+	return 0;
+}
+uint ServerList::Size()
+{
+	return data.Length();
+}
+ServerGroupList::ServerGroupList(char *file,char *link) : link(NULL), file(NULL), modified(0), out_of_sync(false),selected(-1)
+{
+	this->file = file;
+	this->link = link;
+}
+void ServerGroupList::CheckIntegrity()
+{
+	// TODO For now assume it was moddified every 5 min
+	// TODO Later implement If-Modified-Since: HTTP Request
+	this->isOutOfSync();
+	if((difftime(std::time(nullptr),this->modified) >= 300 /*5min*/ ))
+	{
+		if(!out_of_sync)
+			ReceiveModified(true);
+	}
+}
+
+void ServerGroupList::ReceiveModified(bool mod)
+{
+	if(mod)
+	{
+		new SimpleTxtDownloader(this->link, this);
+		this->out_of_sync = true;
+	}	
+}
+
+void ServerGroupList::DataReceived(std::string s)
+{
+	IniFile* ini = new IniFile();
+	ini->LoadFromString(s);
+	this->Load(ini,true);
+	this->Save();
+	this->out_of_sync = false;
+	delete ini;
+}
+void ServerGroupList::Failed()
+{
+}
+
+bool ServerGroupList::isOutOfSync()
+{
+	return this->out_of_sync;
+}
+
+void ServerGroupList::Load(IniFile* ini,bool update)
+{
+	data.Clear();
+	if(!update)
+	{
+		ini = new IniFile();
+		ini->LoadFromDisk(file,BASE_DIR);
+	}else
+	{
+		this->modified = std::time(nullptr);
+	}
+	IniGroup* group = ini->group;
+	IniItem* item;
+	for(;&group != ini->last_group && group != NULL;group = group->next)
+	{
+		if(strcmp(group->name,"details") == 0)
+		{
+			if((item = group->GetItem("modified",false)) == NULL)
+				this->modified = 0;
+			else
+				this->modified = static_cast<time_t>(atol(item->value));
+			continue;
+		}
+		ServerGroup* temp = new ServerGroup();
+		temp->display_name =(item = group->GetItem("display_name",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		temp->selected =((item = group->GetItem("selected",false)) == NULL || item->value == NULL) ? false : (strcmp(item->value,"true") == 0) ? true: false;
+		if(temp->selected)
+			this->selected = data.Length();
+		char *token = (item = group->GetItem("tabs",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		while(token != NULL && token != '\0')
+		{
+			*temp->tabs_name.Append() = strsep(&token,"~");
+		}
+		token = (item = group->GetItem("tabscolour",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		while(token != NULL && token != '\0')
+		{
+			*temp->tabs_colour.Append() = (Colours)(atoi(strsep(&token,"~")));
+		}
+		token = (item = group->GetItem("bgcolour",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		while(token != NULL && token != '\0')
+		{
+			*temp->bg_colour.Append() = (Colours)(atoi(strsep(&token,"~")));
+		}
+		int count;
+		char *ctk = (item = group->GetItem("buttons",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		while(ctk != NULL && ctk != '\0')
+		{
+			token = strsep(&ctk,"~");
+			count = 0;
+			while(token != NULL && token != '\0')
+			{
+				*temp->server_uid.Append() = atoi(strsep(&token,"^"));
+				count++;
+			}
+			*temp->servers_within_group.Append() = count;
+		}
+		ctk = (item = group->GetItem("buttonscolour",false)) == NULL || item->value == NULL ? '\0' : stredup(item->value,NULL);
+		while(ctk != NULL && ctk != '\0')
+		{
+			token = strsep(&ctk,"~");
+			while(token != NULL && token != '\0')
+			{
+				*temp->server_colour.Append() = (Colours)(atoi(strsep(&token,"^")));
+			}
+		}
+		*this->data.Append() = temp;
+	}
+	delete ini;	
+}
+
+void ServerGroupList::Save()
+{
+	IniFile* ini = new IniFile();
+	IniGroup* group = ini->GetGroup("details",0,true);
+	char temp[32];
+	seprintf(temp, lastof(temp),"%ld",this->modified);
+	group->GetItem("modified",true)->SetValue(temp);
+	char info[512];
+	uint length = 0;
+	for(uint i = 0; i < data.Length(); i++)
+	{
+		group = ini->GetGroup(data[i]->display_name,0,true);
+		if(data[i]->display_name != NULL) group->GetItem("display_name",true)->SetValue(data[i]->display_name);
+		group->GetItem("selected",true)->SetValue((data[i]->selected ? "true" : "false"));
+		if(data[i]->tabs_name.Length() != 0)
+		{
+			length = 0;
+			for(uint j = 0; j < data[i]->tabs_name.Length(); j++)
+			{
+				length += seprintf(info+length, lastof(info), "%s~",data[i]->tabs_name[j] );
+			}
+			info[length-1] = '\0';
+			group->GetItem("tabs",true)->SetValue(stredup(info));
+		}
+		if(data[i]->tabs_colour.Length() != 0)
+		{
+			length = 0;
+			for(uint j = 0; j < data[i]->tabs_colour.Length(); j++)
+			{
+				length += seprintf(info+length,lastof(info), "%i~",(int)data[i]->tabs_colour[j]);
+			}
+			info[length-1] = '\0';
+			group->GetItem("tabscolour",true)->SetValue(stredup(info));
+		}
+		if(data[i]->bg_colour.Length() != 0)
+		{
+			length = 0;
+			for(uint j = 0; j < data[i]->bg_colour.Length(); j++)
+			{
+				length += seprintf(info+length,lastof(info), "%i~",(int)data[i]->bg_colour[j]);
+			}
+			info[length-1] = '\0';
+			group->GetItem("bgcolour",true)->SetValue(stredup(info));
+		}
+		if(data[i]->server_uid.Length() != 0)
+		{
+			length = 0;
+			for(uint j = 0,  k = 0, t = data[i]->servers_within_group[0]; j < data[i]->server_uid.Length(); j++)
+			{
+				if(j == t)
+				{
+					info[length-1] = '~';
+					t += data[i]->servers_within_group[++k];
+				}
+				length += seprintf(info+length,lastof(info), "%i^",data[i]->server_uid[j]);
+			}
+			info[length-1] = '\0';
+			group->GetItem("buttons",true)->SetValue(stredup(info));
+		}
+		if(data[i]->server_colour.Length() != 0)
+		{
+			length = 0;
+			for(uint j = 0, k = 0,t = data[i]->servers_within_group[0]; j < data[i]->server_colour.Length(); j++)
+			{
+				if(j == t)
+				{
+					info[length-1] = '~';
+					t += data[i]->servers_within_group[++k];
+				}
+				length += seprintf(info+length,lastof(info), "%i^",(int)data[i]->server_colour[j]);
+			}
+			info[length-1] = '\0';
+			group->GetItem("buttonscolour",true)->SetValue(stredup(info));
+		}
+	}
+	ini->SaveToDisk(file);
+	CSettings::get().RegistUpdate();
+}
+
+ServerGroup *ServerGroupList::Get(uint i)
+{
+	return i <= data.Length()? data[i] : NULL;
+}
+
+ServerGroup *ServerGroupList::GetSelected()
+{
+	if(selected < 0)
+		return NULL;
+	return data[selected];
+}
+int ServerGroupList::SelectedIndex()
+{
+	return this->selected;
+}
+const char* ServerGroupList::SelectedName()
+{
+	if(this->selected < 0)	
+		return "None";
+	return data[selected]->display_name;
+}
+void ServerGroupList::SetSelected(int i)
+{
+	this->selected = i;
+	for(uint j = 0; j <  data.Length(); j++) // TODO Remove redundancy
+	{
+		data[j]->selected = false; 
+	}
+	if(i >= 0)
+		data[i>data.Length() ? data.Length():i]->selected = true; 
+	this->Save();
+}
+
+uint ServerGroupList::Size()
+{
+	return data.Length();
+}
+
+uint ServerGroup::getServerUid(uint g, uint s)
+{
+	int t = 0;
+	for(uint i = 0; i < g; i++)
+		t += this->servers_within_group[i];
+	return this->server_uid[t+s];
+}
+uint ServerGroup::getServer(uint g, uint s)
+{
+	int t = 0;
+	for(uint i = 0; i < g; i++)
+		t += this->servers_within_group[i];
+	return t+s;
+}
diff -r 6e0ffe3d2161 src/nc_csettings.h
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/src/nc_csettings.h	Thu Apr 02 21:37:45 2015 +0100
@@ -0,0 +1,165 @@
+#ifndef NC_CSETTINGS_H
+#define NC_CSETTINGS_H
+
+#include "nc_receiver.h"
+#include "stdafx.h"
+#include "gfx_type.h"
+#include "ini_type.h"
+#include "misc/fixedsizearray.hpp"
+#include <string>
+#include <ctime>
+
+struct Server
+{
+	Server();
+	char* display_name;
+	char* ipv4 ;
+	char* ipv6 ;
+	int port ;
+	uint uid ;
+};
+
+class ServerList : public Receiver
+{
+private:
+	const char *link ;
+	const char *file;
+	FixedSizeArray<Server*,50> data;
+	time_t modified ;
+	bool out_of_sync ;
+public:
+	Server *Get(const char*);
+	Server *Get(uint i);
+	Server *GetByUid(uint i);
+	uint GetPosByUid(uint i);
+	uint Size();
+	void Load(IniFile*,bool);
+	void Save();
+	bool isOutOfSync();
+	
+	void CheckIntegrity();
+	/*virtual*/void ReceiveModified(bool);
+	virtual void DataReceived(std::string);
+	virtual void Failed();
+	ServerList(char *,char*);
+};
+/*struct Admin
+{
+	char* name = NULL;
+	char* role = NULL;
+};*/
+struct ServerGroup
+{
+	const char* display_name;
+	FixedSizeArray<const char*,5> tabs_name;
+	FixedSizeArray<Colours,5> tabs_colour;
+	FixedSizeArray<Colours,5> bg_colour;
+	FixedSizeArray<uint,5> servers_within_group;
+	FixedSizeArray<uint,50> server_uid;
+	FixedSizeArray<Colours,50> server_colour;
+	bool selected = false;
+	uint getServerUid(uint, uint);
+	uint getServer(uint, uint);
+};
+class ServerGroupList : public Receiver
+{
+private:
+	const char *link ;
+	const char *file ;
+	FixedSizeArray<ServerGroup*,10> data;
+	time_t modified = 0;
+	bool out_of_sync = false;
+	int selected ;
+public:
+	ServerGroup *Get(uint i);
+	ServerGroup *GetSelected();
+	int SelectedIndex();
+	const char* SelectedName();
+	uint Size();
+	void Load(IniFile*,bool);
+	void Save();
+	void SetSelected(int);
+	bool isOutOfSync();
+	
+	void CheckIntegrity();
+	/*virtual*/void ReceiveModified(bool);
+	virtual void DataReceived(std::string);
+	virtual void Failed();
+	ServerGroupList(char *,char*);
+};
+
+class CSettings;
+
+class Community : public Receiver
+{
+private:
+	CSettings* _instance ; //XXX for real? yes
+	char* linklist_url ;
+	char* serverlist_url ;
+	char* servergrouplist_url ;
+	char* adminlist_url ;
+	time_t modified ;
+	bool out_of_sync ;
+	
+	ServerList* server_list ;
+	ServerGroupList* servergroup_list ;
+//	AdminList admin_list;
+public:
+	char* display_name ;
+	char* group_name ;
+	char* username;
+	char* password;
+	char* admin;
+	char* adminpass;
+	ServerList* GetServerList();
+	ServerGroup* GetServerGroup();
+	ServerGroupList* GetGroups();
+	void SetGroup(int);
+	void CheckIntegrity();
+	//
+	Community(CSettings*);
+	bool Load(IniGroup*,bool);
+	void Load(const char*, const char*);
+	void Save(IniFile*,bool);
+	bool isOutOfSync();
+	
+	const char* GetName();
+	long int LastModified();
+	
+	/*virtual*/void ReceiveModified(bool);
+	virtual void DataReceived(std::string);
+	virtual void Failed();
+};
+
+
+class CSettings 
+{
+private:
+	void (*thereWasAnUpdate)(void);
+	char *community_file;
+	FixedSizeArray<Community*,10> community_list ;
+	uint selected;
+	
+	CSettings();
+	CSettings(CSettings const&);
+	void operator=(CSettings const&); 
+	void CheckIntegrity();
+public:
+	static CSettings& get();
+
+	bool isThereConnection();
+
+	int Size();
+	Community *GetSelected();
+	void SetSelected(uint i);
+	char *GetCommunityName(int);
+	uint Selected(); 
+	
+	void LoadCommunities();
+	void SaveCommunities();
+	void AddCommunity(const char*, const char*);
+	
+	void RegistToWait(void (*thereWasAnUpdate)(void)); // Poor man observer ? :D
+	void RegistUpdate();
+};
+#endif
diff -r 6e0ffe3d2161 src/nc_receiver.h
--- a/src/nc_receiver.h	Mon Mar 30 14:39:39 2015 +0100
+++ b/src/nc_receiver.h	Thu Apr 02 21:37:45 2015 +0100
@@ -1,3 +1,6 @@
+#ifndef NC_RECEIVER_H
+#define NC_RECEIVER_H
+
 #include <string>
 
 class Receiver
@@ -7,3 +10,5 @@
   virtual void DataReceived(std::string) = 0;
   virtual void Failed() = 0;
 };
+
+#endif
