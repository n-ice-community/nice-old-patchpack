# HG changeset patch
# Parent 06e8776d1dc695e2432370572e119a19257056bd

diff -r 06e8776d1dc6 src/bridge_gui.cpp
--- a/src/bridge_gui.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/bridge_gui.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -24,6 +24,7 @@
 #include "cmd_helper.h"
 #include "tunnelbridge_map.h"
 #include "road_gui.h"
+#include "tilehighlight_func.h"
 
 #include "widgets/bridge_widget.h"
 
@@ -72,6 +73,8 @@
 		DiagDirection start_direction = ReverseDiagDir(GetTunnelBridgeDirection(p1));
 		ConnectRoadToStructure(p1, start_direction);
 	}
+
+	StoreRailPlacementEndpoints(p1, end_tile, (TileX(p1) == TileX(end_tile)) ? TRACK_Y : TRACK_X, false);
 }
 
 /** Window class for handling the bridge-build GUI. */
diff -r 06e8776d1dc6 src/lang/english.txt
--- a/src/lang/english.txt	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/lang/english.txt	Mon Dec 29 16:26:13 2014 +0000
@@ -2319,6 +2319,7 @@
 
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK                   :{BLACK}Build railway track. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL                         :{BLACK}Build railway track using the Autorail mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
+STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL                         :{BLACK}Build railway track using the Polyline mode. Ctrl toggles build/remove for railway construction. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_TRAIN_DEPOT_FOR_BUILDING         :{BLACK}Build train depot (for buying and servicing trains). Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_CONVERT_RAIL_TO_WAYPOINT               :{BLACK}Convert rail to waypoint. Ctrl enables joining waypoints. Shift toggles building/showing cost estimate
 STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_STATION                 :{BLACK}Build railway station. Ctrl enables joining stations. Shift toggles building/showing cost estimate
diff -r 06e8776d1dc6 src/main_gui.cpp
--- a/src/main_gui.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/main_gui.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -107,7 +107,7 @@
 	if (_settings_client.sound.click_beep) SndPlayFx(SND_15_BEEP);
 	w->SetDirty();
 
-	if (w->IsWidgetLowered(widget)) {
+	if (w->IsWidgetLowered(widget) && mode == _thd.place_mode) {
 		ResetObjectToPlace();
 		return false;
 	}
diff -r 06e8776d1dc6 src/misc.cpp
--- a/src/misc.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/misc.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -110,6 +110,7 @@
 	InitializeEconomy();
 
 	ResetObjectToPlace();
+	ClearRailPlacementEndpoints();
 
 	GamelogReset();
 	GamelogStartAction(GLAT_START);
diff -r 06e8776d1dc6 src/rail_cmd.cpp
--- a/src/rail_cmd.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/rail_cmd.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -44,6 +44,7 @@
 typedef SmallVector<Train *, 16> TrainList;
 
 RailtypeInfo _railtypes[RAILTYPE_END];
+TileIndex _rail_track_endtile; ///< The end of a rail track; as hidden return from the rail build/remove command for GUI purposes.
 
 assert_compile(sizeof(_original_railtypes) <= sizeof(_railtypes));
 
@@ -560,6 +561,7 @@
 	}
 
 	cost.AddCost(RailBuildCost(railtype));
+	_rail_track_endtile = tile;
 	return cost;
 }
 
@@ -704,6 +706,7 @@
 		if (v != NULL) TryPathReserve(v, true);
 	}
 
+	_rail_track_endtile = tile;
 	return cost;
 }
 
diff -r 06e8776d1dc6 src/rail_gui.cpp
--- a/src/rail_gui.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/rail_gui.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -52,6 +52,8 @@
 static SignalVariant _cur_signal_variant;    ///< set the signal variant (for signal GUI)
 static SignalType _cur_signal_type;          ///< set the signal type (for signal GUI)
 
+extern TileIndex _rail_track_endtile; // rail_cmd.cpp
+
 /* Map the setting: default_signal_type to the corresponding signal type */
 static const SignalType _default_signal_type[] = {SIGTYPE_NORMAL, SIGTYPE_PBS, SIGTYPE_PBS_ONEWAY};
 
@@ -91,9 +93,9 @@
 	if (result.Succeeded() && _settings_client.sound.confirm) SndPlayTileFx(SND_20_SPLAT_RAIL, tile);
 }
 
-static void GenericPlaceRail(TileIndex tile, int cmd)
+static bool GenericPlaceRail(TileIndex tile, Track track)
 {
-	DoCommandP(tile, _cur_railtype, cmd,
+	return DoCommandP(tile, _cur_railtype, track,
 			_remove_button_clicked ?
 			CMD_REMOVE_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_SINGLE_RAIL | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -276,6 +278,7 @@
 	if (result.Succeeded()) {
 		if (_settings_client.sound.confirm) SndPlayTileFx(SND_20_SPLAT_RAIL, tile);
 		if (!_settings_client.gui.persistent_buildingtools) ResetObjectToPlace();
+		StoreRailPlacementEndpoints(tile, _build_tunnel_endtile, TileX(tile) == TileX(_build_tunnel_endtile) ? TRACK_Y : TRACK_X, false);
 	} else {
 		SetRedErrorSquare(_build_tunnel_endtile);
 	}
@@ -305,7 +308,7 @@
 
 	/* allow ctrl to switch remove mode only for these widgets */
 	for (uint i = WID_RAT_BUILD_NS; i <= WID_RAT_BUILD_STATION; i++) {
-		if ((i <= WID_RAT_AUTORAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
+		if ((i <= WID_RAT_POLYRAIL || i >= WID_RAT_BUILD_WAYPOINT) && w->IsWidgetLowered(i)) {
 			ToggleRailButton_Remove(w);
 			return true;
 		}
@@ -349,9 +352,9 @@
 	}
 }
 
-static void DoRailroadTrack(int mode)
+static bool DoRailroadTrack(TileIndex start_tile, TileIndex end_tile, Track track)
 {
-	DoCommandP(TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), _cur_railtype | (mode << 4),
+	return DoCommandP(start_tile, end_tile, _cur_railtype | (track << 4),
 			_remove_button_clicked ?
 			CMD_REMOVE_RAILROAD_TRACK | CMD_MSG(STR_ERROR_CAN_T_REMOVE_RAILROAD_TRACK) :
 			CMD_BUILD_RAILROAD_TRACK  | CMD_MSG(STR_ERROR_CAN_T_BUILD_RAILROAD_TRACK),
@@ -360,14 +363,14 @@
 
 static void HandleAutodirPlacement()
 {
-	int trackstat = _thd.drawstyle & HT_DIR_MASK; // 0..5
+	Track track = (Track)(_thd.drawstyle & HT_DIR_MASK); // 0..5
+	TileIndex start_tile = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+	TileIndex end_tile = TileVirtXY(_thd.selend.x, _thd.selend.y);
 
-	if (_thd.drawstyle & HT_RAIL) { // one tile case
-		GenericPlaceRail(TileVirtXY(_thd.selend.x, _thd.selend.y), trackstat);
-		return;
+	if ((_thd.drawstyle & HT_RAIL ? GenericPlaceRail(end_tile, track) : DoRailroadTrack(start_tile, end_tile, track))
+			&& !_shift_pressed) {
+		StoreRailPlacementEndpoints(start_tile, _rail_track_endtile, track, true);
 	}
-
-	DoRailroadTrack(trackstat);
 }
 
 /**
@@ -449,6 +452,7 @@
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_EW)->widget_data     = rti->gui_sprites.build_ew_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_Y)->widget_data      = rti->gui_sprites.build_y_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_AUTORAIL)->widget_data     = rti->gui_sprites.auto_rail;
+		this->GetWidget<NWidgetCore>(WID_RAT_POLYRAIL)->widget_data     = rti->gui_sprites.auto_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_DEPOT)->widget_data  = rti->gui_sprites.build_depot;
 		this->GetWidget<NWidgetCore>(WID_RAT_CONVERT_RAIL)->widget_data = rti->gui_sprites.convert_rail;
 		this->GetWidget<NWidgetCore>(WID_RAT_BUILD_TUNNEL)->widget_data = rti->gui_sprites.build_tunnel;
@@ -477,6 +481,7 @@
 			case WID_RAT_BUILD_EW:
 			case WID_RAT_BUILD_Y:
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 			case WID_RAT_BUILD_WAYPOINT:
 			case WID_RAT_BUILD_STATION:
 			case WID_RAT_BUILD_SIGNALS:
@@ -508,6 +513,15 @@
 		}
 	}
 
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget == WID_RAT_POLYRAIL) {
+			Dimension d = GetSpriteSize(SPR_BLOT);
+			uint offset = this->IsWidgetLowered(WID_RAT_POLYRAIL) ? 1 : 0;
+			DrawSprite(SPR_BLOT, PALETTE_TO_GREY, (r.left + r.right - d.width) / 2 + offset, (r.top + r.bottom - d.height) / 2 + offset);
+		}
+	}
+
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		if (widget < WID_RAT_BUILD_NS) return;
@@ -539,6 +553,11 @@
 				this->last_user_action = widget;
 				break;
 
+			case WID_RAT_POLYRAIL:
+				HandlePlacePushButton(this, WID_RAT_POLYRAIL, GetRailTypeInfo(railtype)->cursor.autorail, HT_RAIL | HT_POLY);
+				this->last_user_action = widget;
+				break;
+
 			case WID_RAT_DEMOLISH:
 				HandlePlacePushButton(this, WID_RAT_DEMOLISH, ANIMCURSOR_DEMOLISH, HT_RECT | HT_DIAGONAL);
 				this->last_user_action = widget;
@@ -626,6 +645,7 @@
 				break;
 
 			case WID_RAT_AUTORAIL:
+			case WID_RAT_POLYRAIL:
 				VpStartPlaceSizing(tile, VPM_RAILDIRS, DDSP_PLACE_RAIL);
 				break;
 
@@ -773,6 +793,7 @@
 }
 
 const uint16 _railtoolbar_autorail_keys[] = {'5', 'A' | WKC_GLOBAL_HOTKEY, 0};
+const uint16 _railtoolbar_polyrail_keys[] = {'5' | WKC_CTRL, 'A' | WKC_GLOBAL_HOTKEY | WKC_CTRL, 0};
 
 static Hotkey railtoolbar_hotkeys[] = {
 	Hotkey('1', "build_ns", WID_RAT_BUILD_NS),
@@ -780,6 +801,7 @@
 	Hotkey('3', "build_ew", WID_RAT_BUILD_EW),
 	Hotkey('4', "build_y", WID_RAT_BUILD_Y),
 	Hotkey(_railtoolbar_autorail_keys, "autorail", WID_RAT_AUTORAIL),
+	Hotkey(_railtoolbar_polyrail_keys, "polyrail", WID_RAT_POLYRAIL),
 	Hotkey('6', "demolish", WID_RAT_DEMOLISH),
 	Hotkey('7', "depot", WID_RAT_BUILD_DEPOT),
 	Hotkey('8', "waypoint", WID_RAT_BUILD_WAYPOINT),
@@ -810,6 +832,8 @@
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_RAIL_NW, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_RAILROAD_TRACK),
 		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_AUTORAIL),
 						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_AUTORAIL),
+		NWidget(WWT_IMGBTN, COLOUR_DARK_GREEN, WID_RAT_POLYRAIL),
+						SetFill(0, 1), SetMinimalSize(22, 22), SetDataTip(SPR_IMG_AUTORAIL, STR_RAIL_TOOLBAR_TOOLTIP_BUILD_POLYRAIL),
 
 		NWidget(WWT_PANEL, COLOUR_DARK_GREEN), SetMinimalSize(4, 22), SetDataTip(0x0, STR_NULL), EndContainer(),
 
diff -r 06e8776d1dc6 src/script/api/game/game_window.hpp.sq
--- a/src/script/api/game/game_window.hpp.sq	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/script/api/game/game_window.hpp.sq	Mon Dec 29 16:26:13 2014 +0000
@@ -904,6 +904,7 @@
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_EW,                          "WID_RAT_BUILD_EW");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_Y,                           "WID_RAT_BUILD_Y");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_AUTORAIL,                          "WID_RAT_AUTORAIL");
+	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_POLYRAIL,                          "WID_RAT_POLYRAIL");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_DEMOLISH,                          "WID_RAT_DEMOLISH");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_DEPOT,                       "WID_RAT_BUILD_DEPOT");
 	SQGSWindow.DefSQConst(engine, ScriptWindow::WID_RAT_BUILD_WAYPOINT,                    "WID_RAT_BUILD_WAYPOINT");
diff -r 06e8776d1dc6 src/script/api/script_window.hpp
--- a/src/script/api/script_window.hpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/script/api/script_window.hpp	Mon Dec 29 16:26:13 2014 +0000
@@ -1982,6 +1982,7 @@
 		WID_RAT_BUILD_EW                             = ::WID_RAT_BUILD_EW,                             ///< Build rail along the game view X axis.
 		WID_RAT_BUILD_Y                              = ::WID_RAT_BUILD_Y,                              ///< Build rail along the game grid Y axis.
 		WID_RAT_AUTORAIL                             = ::WID_RAT_AUTORAIL,                             ///< Autorail tool.
+		WID_RAT_POLYRAIL                             = ::WID_RAT_POLYRAIL,                             ///< Polyline rail tool.
 		WID_RAT_DEMOLISH                             = ::WID_RAT_DEMOLISH,                             ///< Destroy something with dynamite!
 		WID_RAT_BUILD_DEPOT                          = ::WID_RAT_BUILD_DEPOT,                          ///< Build a depot.
 		WID_RAT_BUILD_WAYPOINT                       = ::WID_RAT_BUILD_WAYPOINT,                       ///< Build a waypoint.
diff -r 06e8776d1dc6 src/tilehighlight_func.h
--- a/src/tilehighlight_func.h	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/tilehighlight_func.h	Mon Dec 29 16:26:13 2014 +0000
@@ -14,6 +14,7 @@
 
 #include "gfx_type.h"
 #include "tilehighlight_type.h"
+#include "track_type.h"
 
 void PlaceProc_DemolishArea(TileIndex tile);
 bool GUIPlaceProcDragXY(ViewportDragDropSelectionProcess proc, TileIndex start_tile, TileIndex end_tile);
@@ -30,6 +31,9 @@
 
 void UpdateTileSelection();
 
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional = true);
+void ClearRailPlacementEndpoints();
+
 extern TileHighlightData _thd;
 
 #endif /* TILEHIGHLIGHT_FUNC_H */
diff -r 06e8776d1dc6 src/tilehighlight_type.h
--- a/src/tilehighlight_type.h	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/tilehighlight_type.h	Mon Dec 29 16:26:13 2014 +0000
@@ -28,6 +28,7 @@
 	HT_RAIL      = 0x080, ///< autorail (one piece), lower bits: direction
 	HT_VEHICLE   = 0x100, ///< vehicle is accepted as target as well (bitmask)
 	HT_DIAGONAL  = 0x200, ///< Also allow 'diagonal rectangles'. Only usable in combination with #HT_RECT or #HT_POINT.
+	HT_POLY      = 0x400, ///< polyline mode; connect highlighted track with previous one
 	HT_DRAG_MASK = 0x0F8, ///< Mask for the tile drag-type modes.
 
 	/* lower bits (used with HT_LINE and HT_RAIL):
@@ -54,11 +55,15 @@
 
 	Point new_pos;       ///< New value for \a pos; used to determine whether to redraw the selection.
 	Point new_size;      ///< New value for \a size; used to determine whether to redraw the selection.
+	Point new_offs;      ///< New value for \a offs; used to determine whether to redraw the selection.
 	Point new_outersize; ///< New value for \a outersize; used to determine whether to redraw the selection.
 	byte dirty;          ///< Whether the build station window needs to redraw due to the changed selection.
 
 	Point selstart;      ///< The location where the dragging started.
 	Point selend;        ///< The location where the drag currently ends.
+	Point selstart2;     ///< The location where the second segment of a polyline track starts.
+	Point selend2;       ///< The location where the second segment of a polyline track ends.
+	HighLightStyle dir2; ///< Direction of the second segment of a polyline track, HT_DIR_END if second segment is not selected.
 	byte sizelimit;      ///< Whether the selection is limited in length, and what the maximum length is.
 
 	HighLightStyle drawstyle;      ///< Lower bits 0-3 are reserved for detailed highlight information.
diff -r 06e8776d1dc6 src/viewport.cpp
--- a/src/viewport.cpp	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/viewport.cpp	Mon Dec 29 16:26:13 2014 +0000
@@ -69,6 +69,8 @@
  */
 
 #include "stdafx.h"
+#include "core/math_func.hpp"
+#include "core/smallvec_type.hpp"
 #include "landscape.h"
 #include "viewport_func.h"
 #include "station_base.h"
@@ -151,6 +153,28 @@
 typedef SmallVector<ParentSpriteToDraw, 64> ParentSpriteToDrawVector;
 typedef SmallVector<ChildScreenSpriteToDraw, 16> ChildScreenSpriteToDrawVector;
 
+/**
+ * Snapping point for a track.
+ *
+ * Point where a track (rail/road/other) can be snapped to while selecting tracks with polyline
+ * tool (HT_POLY). Besides of x/y coordinates expressed in tile "units" it contains a set of
+ * allowed line directions.
+ */
+struct LineSnapPoint : Point {
+	uint8 dirs; ///< Allowed line directions, set of #Direction bits.
+};
+
+typedef SmallVector<LineSnapPoint, 4> LineSnapPoints; ///< Set of snapping points
+
+/** Coordinates of a polyline track made of 2 connected line segments. */
+struct Polyline {
+	Point start;           ///< The point where the first segment starts (as given in LineSnapPoint).
+	Direction first_dir;   ///< Direction of the first line segment.
+	uint first_len;        ///< Length of the first segment - number of track pieces.
+	Direction second_dir;  ///< Direction of the second line segment.
+	uint second_len;       ///< Length of the second segment - number of track pieces.
+};
+
 /** Data structure storing rendering information */
 struct ViewportDrawer {
 	DrawPixelInfo dpi;
@@ -176,6 +200,8 @@
 static ViewportDrawer _vd;
 
 TileHighlightData _thd;
+static LineSnapPoints _rail_snap_points; ///< Set of points where a rail track will be snapped to (polyline tool).
+static LineSnapPoint _current_snap_lock; ///< Start point and direction at which selected track is locked on currently (while dragging in polyline mode).
 static TileInfo *_cur_ti;
 bool _draw_bounding_boxes = false;
 bool _draw_dirty_blocks = false;
@@ -808,13 +834,17 @@
 }
 
 /**
- * Checks whether a point is inside the selected a diagonal rectangle given by _thd.size and _thd.pos
+ * Checks whether a point is inside the selected rectangle given by _thd.size, _thd.pos and _thd.diagonal
  * @param x The x coordinate of the point to be checked.
  * @param y The y coordinate of the point to be checked.
  * @return True if the point is inside the rectangle, else false.
  */
-bool IsInsideRotatedRectangle(int x, int y)
+static bool IsInsideSelectedRectangle(int x, int y)
 {
+	if (!_thd.diagonal) {
+		return IsInsideBS(x, _thd.pos.x, _thd.size.x) && IsInsideBS(y, _thd.pos.y, _thd.size.y);
+	}
+
 	int dist_a = (_thd.size.x + _thd.size.y);      // Rotated coordinate system for selected rectangle.
 	int dist_b = (_thd.size.x - _thd.size.y);      // We don't have to divide by 2. It's all relative!
 	int a = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny.
@@ -931,53 +961,45 @@
 	DrawSelectionSprite(sel, pal, ti, 7, FOUNDATION_PART_NORMAL);
 }
 
-static bool IsPartOfAutoLine(int px, int py)
+static HighLightStyle GetPartOfAutoLine(int px, int py, const Point &selstart, const Point &selend, HighLightStyle dir)
 {
-	px -= _thd.selstart.x;
-	py -= _thd.selstart.y;
-
-	if ((_thd.drawstyle & HT_DRAG_MASK) != HT_LINE) return false;
-
-	switch (_thd.drawstyle & HT_DIR_MASK) {
-		case HT_DIR_X:  return py == 0; // x direction
-		case HT_DIR_Y:  return px == 0; // y direction
-		case HT_DIR_HU: return px == -py || px == -py - 16; // horizontal upper
-		case HT_DIR_HL: return px == -py || px == -py + 16; // horizontal lower
-		case HT_DIR_VL: return px == py || px == py + 16; // vertical left
-		case HT_DIR_VR: return px == py || px == py - 16; // vertical right
-		default:
-			NOT_REACHED();
+	if (!IsInRangeInclusive(selstart.x & ~TILE_UNIT_MASK, selend.x & ~TILE_UNIT_MASK, px)) return HT_DIR_END;
+	if (!IsInRangeInclusive(selstart.y & ~TILE_UNIT_MASK, selend.y & ~TILE_UNIT_MASK, py)) return HT_DIR_END;
+
+	px -= selstart.x & ~TILE_UNIT_MASK;
+	py -= selstart.y & ~TILE_UNIT_MASK;
+
+	switch (dir) {
+		case HT_DIR_X: return (py == 0) ? HT_DIR_X : HT_DIR_END;
+		case HT_DIR_Y: return (px == 0) ? HT_DIR_Y : HT_DIR_END;
+		case HT_DIR_HU: return (px == -py) ? HT_DIR_HU : (px == -py - (int)TILE_SIZE) ? HT_DIR_HL : HT_DIR_END;
+		case HT_DIR_HL: return (px == -py) ? HT_DIR_HL : (px == -py + (int)TILE_SIZE) ? HT_DIR_HU : HT_DIR_END;
+		case HT_DIR_VL: return (px ==  py) ? HT_DIR_VL : (px ==  py + (int)TILE_SIZE) ? HT_DIR_VR : HT_DIR_END;
+		case HT_DIR_VR: return (px ==  py) ? HT_DIR_VR : (px ==  py - (int)TILE_SIZE) ? HT_DIR_VL : HT_DIR_END;
+		default: NOT_REACHED(); break;
 	}
+
+	return HT_DIR_END;
 }
 
-/* [direction][side] */
-static const HighLightStyle _autorail_type[6][2] = {
-	{ HT_DIR_X,  HT_DIR_X },
-	{ HT_DIR_Y,  HT_DIR_Y },
-	{ HT_DIR_HU, HT_DIR_HL },
-	{ HT_DIR_HL, HT_DIR_HU },
-	{ HT_DIR_VL, HT_DIR_VR },
-	{ HT_DIR_VR, HT_DIR_VL }
-};
-
 #include "table/autorail.h"
 
 /**
  * Draws autorail highlights.
  *
  * @param *ti TileInfo Tile that is being drawn
- * @param autorail_type Offset into _AutorailTilehSprite[][]
+ * @param autorail_type \c HT_DIR_XXX, offset into _AutorailTilehSprite[][]
+ * @param pal Palette to use, -1 to autodetect
  */
-static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
+static void DrawAutorailSelection(const TileInfo *ti, HighLightStyle autorail_type, PaletteID pal = -1)
 {
 	SpriteID image;
-	PaletteID pal;
 	int offset;
 
 	FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
 	Slope autorail_tileh = RemoveHalftileSlope(ti->tileh);
 	if (IsHalftileSlope(ti->tileh)) {
-		static const uint _lower_rail[4] = { 5U, 2U, 4U, 3U };
+		static const HighLightStyle _lower_rail[CORNER_END] = { HT_DIR_VR, HT_DIR_HU, HT_DIR_VL, HT_DIR_HL }; // CORNER_W, CORNER_S, CORNER_E, CORNER_N
 		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
 		if (autorail_type != _lower_rail[halftile_corner]) {
 			foundation_part = FOUNDATION_PART_HALFTILE;
@@ -986,16 +1008,17 @@
 		}
 	}
 
+	assert(autorail_type < HT_DIR_END);
 	offset = _AutorailTilehSprite[autorail_tileh][autorail_type];
 	if (offset >= 0) {
 		image = SPR_AUTORAIL_BASE + offset;
-		pal = PAL_NONE;
+		if (pal == (PaletteID)-1) pal = _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE;
 	} else {
 		image = SPR_AUTORAIL_BASE - offset;
-		pal = PALETTE_SEL_TILE_RED;
+		if (pal == (PaletteID)-1) pal = PALETTE_SEL_TILE_RED;
 	}
 
-	DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : pal, ti, 7, foundation_part);
+	DrawSelectionSprite(image, pal, ti, 7, foundation_part);
 }
 
 /**
@@ -1008,66 +1031,61 @@
 	bool is_redsq = _thd.redsq == ti->tile;
 	if (is_redsq) DrawTileSelectionRect(ti, PALETTE_TILE_RED_PULSATING);
 
-	/* No tile selection active? */
-	if ((_thd.drawstyle & HT_DRAG_MASK) == HT_NONE) return;
-
-	if (_thd.diagonal) { // We're drawing a 45 degrees rotated (diagonal) rectangle
-		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) goto draw_inner;
-		return;
-	}
-
-	/* Inside the inner area? */
-	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
-			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
-draw_inner:
-		if (_thd.drawstyle & HT_RECT) {
-			if (!is_redsq) DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
-		} else if (_thd.drawstyle & HT_POINT) {
-			/* Figure out the Z coordinate for the single dot. */
-			int z = 0;
-			FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
-			if (ti->tileh & SLOPE_N) {
-				z += TILE_HEIGHT;
-				if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
-			}
-			if (IsHalftileSlope(ti->tileh)) {
-				Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
-				if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
-				if (halftile_corner != CORNER_S) {
-					foundation_part = FOUNDATION_PART_HALFTILE;
-					if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+	switch (_thd.drawstyle & HT_DRAG_MASK) {
+		default: break; // No tile selection active?
+
+		case HT_RECT:
+			if (!is_redsq) {
+				if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+					DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
+				} else if (_thd.outersize.x > 0 &&
+						/* Check if it's inside the outer area? */
+						IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
+						IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
+					/* Draw a blue rect. */
+					DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
 				}
 			}
-			DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
-		} else if (_thd.drawstyle & HT_RAIL) {
-			/* autorail highlight piece under cursor */
-			HighLightStyle type = _thd.drawstyle & HT_DIR_MASK;
-			assert(type < HT_DIR_END);
-			DrawAutorailSelection(ti, _autorail_type[type][0]);
-		} else if (IsPartOfAutoLine(ti->x, ti->y)) {
-			/* autorail highlighting long line */
-			HighLightStyle dir = _thd.drawstyle & HT_DIR_MASK;
-			uint side;
-
-			if (dir == HT_DIR_X || dir == HT_DIR_Y) {
-				side = 0;
-			} else {
-				TileIndex start = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-				side = Delta(Delta(TileX(start), TileX(ti->tile)), Delta(TileY(start), TileY(ti->tile)));
+			break;
+
+		case HT_POINT:
+			if (IsInsideSelectedRectangle(ti->x, ti->y)) {
+				/* Figure out the Z coordinate for the single dot. */
+				int z = 0;
+				FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+				if (ti->tileh & SLOPE_N) {
+					z += TILE_HEIGHT;
+					if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+				}
+				if (IsHalftileSlope(ti->tileh)) {
+					Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+					if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
+					if (halftile_corner != CORNER_S) {
+						foundation_part = FOUNDATION_PART_HALFTILE;
+						if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+					}
+				}
+				DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
 			}
-
-			DrawAutorailSelection(ti, _autorail_type[dir][side]);
+			break;
+
+		case HT_RAIL:
+			if (ti->tile == TileVirtXY(_thd.pos.x, _thd.pos.y)) {
+				assert((_thd.drawstyle & HT_DIR_MASK) < HT_DIR_END);
+				DrawAutorailSelection(ti, _thd.drawstyle & HT_DIR_MASK);
+			}
+			break;
+
+		case HT_LINE: {
+			HighLightStyle type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart, _thd.selend, _thd.drawstyle & HT_DIR_MASK);
+			if (type < HT_DIR_END) {
+				DrawAutorailSelection(ti, type);
+			} else if ((_thd.drawstyle & HT_POLY) && _thd.dir2 < HT_DIR_END) {
+				type = GetPartOfAutoLine(ti->x, ti->y, _thd.selstart2, _thd.selend2, _thd.dir2);
+				if (type < HT_DIR_END) DrawAutorailSelection(ti, type, PALETTE_SEL_TILE_BLUE);
+			}
+			break;
 		}
-		return;
-	}
-
-	/* Check if it's inside the outer area? */
-	if (!is_redsq && _thd.outersize.x > 0 &&
-			IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
-			IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
-		/* Draw a blue rect. */
-		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
-		return;
 	}
 }
 
@@ -2268,7 +2286,7 @@
 		int x_start = _thd.pos.x;
 		int y_start = _thd.pos.y;
 
-		if (_thd.outersize.x != 0) {
+		if (_thd.outersize.x != 0 || _thd.outersize.y != 0) {
 			x_size  += _thd.outersize.x;
 			x_start += _thd.offs.x;
 			y_size  += _thd.outersize.y;
@@ -2627,8 +2645,8 @@
 
 void SetTileSelectBigSize(int ox, int oy, int sx, int sy)
 {
-	_thd.offs.x = ox * TILE_SIZE;
-	_thd.offs.y = oy * TILE_SIZE;
+	_thd.new_offs.x = ox * TILE_SIZE;
+	_thd.new_offs.y = oy * TILE_SIZE;
 	_thd.new_outersize.x = sx * TILE_SIZE;
 	_thd.new_outersize.y = sy * TILE_SIZE;
 }
@@ -2668,7 +2686,36 @@
 	return FindWindowById(this->window_class, this->window_number);
 }
 
-
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging);
+
+static inline void CalcNewPolylineOutersize()
+{
+	/* use the 'outersize' to mark the second (blue) part of a polyline selection */
+	if (_thd.dir2 < HT_DIR_END) {
+		/* get bounds of the second part */
+		int outer_x1 = _thd.selstart2.x & ~TILE_UNIT_MASK;
+		int outer_y1 = _thd.selstart2.y & ~TILE_UNIT_MASK;
+		int outer_x2 = _thd.selend2.x & ~TILE_UNIT_MASK;
+		int outer_y2 = _thd.selend2.y & ~TILE_UNIT_MASK;
+		if (outer_x1 > outer_x2) Swap(outer_x1, outer_x2);
+		if (outer_y1 > outer_y2) Swap(outer_y1, outer_y2);
+		/* include the first part */
+		outer_x1 = min<int>(outer_x1, _thd.new_pos.x);
+		outer_y1 = min<int>(outer_y1, _thd.new_pos.y);
+		outer_x2 = max<int>(outer_x2, _thd.new_pos.x + _thd.new_size.x - TILE_SIZE);
+		outer_y2 = max<int>(outer_y2, _thd.new_pos.y + _thd.new_size.y - TILE_SIZE);
+		/* write new values */
+		_thd.new_offs.x = outer_x1 - _thd.new_pos.x;
+		_thd.new_offs.y = outer_y1 - _thd.new_pos.y;
+		_thd.new_outersize.x = outer_x2 - outer_x1 + TILE_SIZE - _thd.new_size.x;
+		_thd.new_outersize.y = outer_y2 - outer_y1 + TILE_SIZE - _thd.new_size.y;
+	} else {
+		_thd.new_offs.x = 0;
+		_thd.new_offs.y = 0;
+		_thd.new_outersize.x = 0;
+		_thd.new_outersize.y = 0;
+	}
+}
 
 /**
  * Updates tile highlighting for all cases.
@@ -2708,6 +2755,9 @@
 				_thd.new_size.x += TILE_SIZE;
 				_thd.new_size.y += TILE_SIZE;
 			}
+			if (_thd.place_mode & HT_POLY) {
+				CalcNewPolylineOutersize();
+			}
 			new_drawstyle = _thd.next_drawstyle;
 		}
 	} else if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
@@ -2725,10 +2775,39 @@
 					y1 += TILE_SIZE / 2;
 					break;
 				case HT_RAIL:
-					/* Draw one highlighted tile in any direction */
-					new_drawstyle = GetAutorailHT(pt.x, pt.y);
-					break;
 				case HT_LINE:
+					/* HT_POLY */
+					if (_thd.place_mode & HT_POLY) {
+						if (_rail_snap_points.Length() > 0) {
+							new_drawstyle = CalcPolyrailDrawstyle(pt, false);
+							if (new_drawstyle != HT_NONE) {
+								x1 = _thd.selstart.x & ~TILE_UNIT_MASK;
+								y1 = _thd.selstart.y & ~TILE_UNIT_MASK;
+								int x2 = _thd.selend.x & ~TILE_UNIT_MASK;
+								int y2 = _thd.selend.y & ~TILE_UNIT_MASK;
+								if (x1 > x2) Swap(x1, x2);
+								if (y1 > y2) Swap(y1, y2);
+								_thd.new_pos.x = x1;
+								_thd.new_pos.y = y1;
+								_thd.new_size.x = x2 - x1 + TILE_SIZE;
+								_thd.new_size.y = y2 - y1 + TILE_SIZE;
+								CalcNewPolylineOutersize();
+							}
+							break;
+						}
+						_thd.new_offs.x = 0;
+						_thd.new_offs.y = 0;
+						_thd.new_outersize.x = 0;
+						_thd.new_outersize.y = 0;
+						_thd.dir2 = HT_DIR_END;
+					}
+					/* HT_RAIL */
+					if (_thd.place_mode & HT_RAIL) {
+						/* Draw one highlighted tile in any direction */
+						new_drawstyle = GetAutorailHT(pt.x, pt.y);
+						break;
+					}
+					/* HT_LINE */
 					switch (_thd.place_mode & HT_DIR_MASK) {
 						case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
 						case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
@@ -2747,6 +2826,8 @@
 					}
 					_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
 					_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
+					_thd.selend.x = x1;
+					_thd.selend.y = y1;
 					break;
 				default:
 					NOT_REACHED();
@@ -2761,6 +2842,7 @@
 	if (_thd.drawstyle != new_drawstyle ||
 			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
 			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
+			_thd.offs.x != _thd.new_offs.x || _thd.offs.y != _thd.new_offs.y ||
 			_thd.outersize.x != _thd.new_outersize.x ||
 			_thd.outersize.y != _thd.new_outersize.y ||
 			_thd.diagonal    != new_diagonal) {
@@ -2770,6 +2852,7 @@
 		_thd.drawstyle = new_drawstyle;
 		_thd.pos = _thd.new_pos;
 		_thd.size = _thd.new_size;
+		_thd.offs = _thd.new_offs;
 		_thd.outersize = _thd.new_outersize;
 		_thd.diagonal = new_diagonal;
 		_thd.dirty = 0xff;
@@ -2819,6 +2902,7 @@
 	} else if (_thd.place_mode & (HT_RAIL | HT_LINE)) {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = _thd.drawstyle | others;
+		_current_snap_lock.x = -1;
 	} else {
 		_thd.place_mode = HT_SPECIAL | others;
 		_thd.next_drawstyle = HT_POINT | others;
@@ -3010,7 +3094,31 @@
 	return (int)(h1 - h0) * TILE_HEIGHT_STEP;
 }
 
-static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+static void ShowLengthMeasurement(HighLightStyle style, TileIndex start_tile, TileIndex end_tile, TooltipCloseCondition close_cond = TCC_LEFT_CLICK, bool show_single_tile_length = false)
+{
+	static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+
+	if (_settings_client.gui.measure_tooltip) {
+		uint distance = DistanceManhattan(start_tile, end_tile) + 1;
+		byte index = 0;
+		uint64 params[2];
+
+		if (show_single_tile_length || distance != 1) {
+			int heightdiff = CalcHeightdiff(style, distance, start_tile, end_tile);
+			/* If we are showing a tooltip for horizontal or vertical drags,
+			 * 2 tiles have a length of 1. To bias towards the ceiling we add
+			 * one before division. It feels more natural to count 3 lengths as 2 */
+			if ((style & HT_DIR_MASK) != HT_DIR_X && (style & HT_DIR_MASK) != HT_DIR_Y) {
+				distance = CeilDiv(distance, 2);
+			}
+
+			params[index++] = distance;
+			if (heightdiff != 0) params[index++] = heightdiff;
+		}
+
+		ShowMeasurementTooltips(measure_strings_length[index], index, params, close_cond);
+	}
+}
 
 /**
  * Check for underflowing the map.
@@ -3041,6 +3149,162 @@
 	test = max;
 }
 
+static const uint X_DIRS = (1 << DIR_NE) | (1 << DIR_SW);
+static const uint Y_DIRS = (1 << DIR_SE) | (1 << DIR_NW);
+static const uint HORZ_DIRS = (1 << DIR_W) | (1 << DIR_E);
+static const uint VERT_DIRS = (1 << DIR_N) | (1 << DIR_S);
+
+Trackdir PointDirToTrackdir(const Point &pt, Direction dir)
+{
+	Trackdir ret;
+
+	if (IsDiagonalDirection(dir)) {
+		ret = DiagDirToDiagTrackdir(DirToDiagDir(dir));
+	} else {
+		int x = pt.x & TILE_UNIT_MASK;
+		int y = pt.y & TILE_UNIT_MASK;
+		int ns = x + y;
+		int we = y - x;
+		if (HasBit(HORZ_DIRS, dir)) {
+			ret = TrackDirectionToTrackdir(ns < (int)TILE_SIZE ? TRACK_UPPER : TRACK_LOWER, dir);
+		} else {
+			ret = TrackDirectionToTrackdir(we < 0 ? TRACK_LEFT : TRACK_RIGHT, dir);
+		}
+	}
+
+	return ret;
+}
+
+static bool FindPolyline(const Point &pt, const LineSnapPoint &start, Polyline *ret)
+{
+	/* relative coordinats of the mouse point (offset against the snap point) */
+	int x = pt.x - start.x;
+	int y = pt.y - start.y;
+	int we = y - x;
+	int ns = x + y;
+
+	/* in-tile alignment of the snap point (there are two variants: [0, 8] or [8, 0]) */
+	uint align_x = start.x & TILE_UNIT_MASK;
+	uint align_y = start.y & TILE_UNIT_MASK;
+	assert((align_x == TILE_SIZE / 2 && align_y == 0 && !(start.dirs & X_DIRS)) || (align_x == 0 && align_y == TILE_SIZE / 2 && !(start.dirs & Y_DIRS)));
+
+	/* absolute distance between points (in tiles) */
+	uint d_x = abs(RoundDivSU(x < 0 ? x - align_y : x + align_y, TILE_SIZE));
+	uint d_y = abs(RoundDivSU(y < 0 ? y - align_x : y + align_x, TILE_SIZE));
+	uint d_ns = abs(RoundDivSU(ns, TILE_SIZE));
+	uint d_we = abs(RoundDivSU(we, TILE_SIZE));
+
+	/* Find on which quadrant is the mouse point (reltively to the snap point).
+	 * Numeration (clockwise like in Direction):
+	 * ortho            diag
+	 *   \   2   /       2 | 3
+	 *     \   /         --+---> [we]
+	 *  1    X    3      1 | 0
+	 *     /   \           v
+	 *  [x]  0  [y]       [ns]          */
+	uint ortho_quadrant = 2 * (x < 0) + ((x < 0) != (y < 0)); // implicit cast: false/true --> 0/1
+	uint diag_quadrant = 2 * (ns < 0) + ((ns < 0) != (we < 0));
+
+	/* direction from the snap point to the mouse point */
+	Direction ortho_line_dir = ChangeDir(DIR_S, (DirDiff)(2 * ortho_quadrant)); // DIR_S is the middle of the ortho quadrant no. 0
+	Direction diag_line_dir = ChangeDir(DIR_SE, (DirDiff)(2 * diag_quadrant));  // DIR_SE is the middle of the diag quadrant no. 0
+	if (!HasBit(start.dirs, ortho_line_dir) && !HasBit(start.dirs, diag_line_dir)) return false;
+
+	/* length of booth segments of auto line (choosing orthogonal direction first) */
+	uint ortho_len = 0, ortho_len2 = 0;
+	if (HasBit(start.dirs, ortho_line_dir)) {
+		bool is_len_even = (align_x != 0) ? d_x >= d_y : d_x <= d_y;
+		ortho_len = 2 * min(d_x, d_y) - (int)is_len_even;
+		assert((int)ortho_len >= 0);
+		if (d_ns == 0 || d_we == 0) { // just single segment?
+			ortho_len++;
+		} else {
+			ortho_len2 = abs((int)d_x - (int)d_y) + (int)is_len_even;
+		}
+	}
+
+	/* length of booth segments of auto line (choosing diagonal direction first) */
+	uint diag_len = 0, diag_len2 = 0;
+	if (HasBit(start.dirs, diag_line_dir)) {
+		if (d_x == 0 || d_y == 0) { // just single segment?
+			diag_len = d_x + d_y;
+		} else {
+			diag_len = min(d_ns, d_we);
+			diag_len2 = d_x + d_y - diag_len;
+		}
+	}
+
+	/* choose the best variant */
+	if (ortho_len != 0 && diag_len != 0) {
+		/* in the first place, choose this line whose first segment ends up closer
+		 * to the mouse point (thus the second segment is shorter) */
+		int cmp = ortho_len2 - diag_len2;
+		/* if equeal, choose the shorter line */
+		if (cmp == 0) cmp = ortho_len - diag_len;
+		/* finally look at small "units" and choose the line which is closer to the mouse point */
+		if (cmp == 0) cmp = min(abs(we), abs(ns)) - min(abs(x), abs(y));
+		/* based on comparison, disable one of variants */
+		if (cmp > 0) {
+			ortho_len = 0;
+		} else {
+			diag_len = 0;
+		}
+	}
+
+	/* store results */
+	if (ortho_len != 0) {
+		ret->first_dir = ortho_line_dir;
+		ret->first_len = ortho_len;
+		ret->second_dir = (ortho_len2 != 0) ? diag_line_dir : INVALID_DIR;
+		ret->second_len = ortho_len2;
+	} else if (diag_len != 0) {
+		ret->first_dir = diag_line_dir;
+		ret->first_len = diag_len;
+		ret->second_dir = (diag_len2 != 0) ? ortho_line_dir : INVALID_DIR;
+		ret->second_len = diag_len2;
+	} else {
+		return false;
+	}
+
+	ret->start = start;
+	return true;
+}
+
+/**
+ * Calculate squared euclidean distance between two points.
+ * @param a the first point
+ * @param b the second point
+ * @return |b - a| ^ 2
+ */
+static inline uint SqrDist(const Point &a, const Point &b)
+{
+	return (b.x - a.x) * (b.x - a.x) + (b.y - a.y) * (b.y - a.y);
+}
+
+static LineSnapPoint *FindBestPolyline(const Point &pt, LineSnapPoint *snap_points, uint num_points, Polyline *ret)
+{
+	while (num_points > 0) {
+		/* run a single bubble sort loop to find the closest snap point (push it to the and of the array) */
+		uint prev_dist = SqrDist(snap_points[0], pt);
+		for (uint i = 1; i < num_points; i++) {
+			uint next_dist = SqrDist(snap_points[i], pt);
+			if (prev_dist < next_dist) {
+				Swap(snap_points[i], snap_points[i - 1]);
+			} else {
+				prev_dist = next_dist;
+			}
+		}
+
+		/* try to fit a line */
+		if (FindPolyline(pt, snap_points[num_points - 1], ret)) return &snap_points[num_points - 1];
+
+		/* repeat procedure for the rest of snap points */
+		--num_points;
+	}
+
+	return NULL;
+}
+
 /** while dragging */
 static void CalcRaildirsDrawstyle(int x, int y, int method)
 {
@@ -3227,32 +3491,78 @@
 		}
 	}
 
-	if (_settings_client.gui.measure_tooltip) {
-		TileIndex t0 = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
-		TileIndex t1 = TileVirtXY(x, y);
-		uint distance = DistanceManhattan(t0, t1) + 1;
-		byte index = 0;
-		uint64 params[2];
-
-		if (distance != 1) {
-			int heightdiff = CalcHeightdiff(b, distance, t0, t1);
-			/* If we are showing a tooltip for horizontal or vertical drags,
-			 * 2 tiles have a length of 1. To bias towards the ceiling we add
-			 * one before division. It feels more natural to count 3 lengths as 2 */
-			if ((b & HT_DIR_MASK) != HT_DIR_X && (b & HT_DIR_MASK) != HT_DIR_Y) {
-				distance = CeilDiv(distance, 2);
-			}
-
-			params[index++] = distance;
-			if (heightdiff != 0) params[index++] = heightdiff;
-		}
-
-		ShowMeasurementTooltips(measure_strings_length[index], index, params);
-	}
-
 	_thd.selend.x = x;
 	_thd.selend.y = y;
 	_thd.next_drawstyle = b;
+
+	ShowLengthMeasurement(b, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y));
+}
+
+static HighLightStyle CalcPolyrailDrawstyle(Point pt, bool dragging)
+{
+	/* find the best track */
+	Polyline line;
+
+	HighLightStyle ret = HT_LINE | HT_POLY;
+
+	if (!dragging) {
+		_current_snap_lock.x = -1;
+		if (FindBestPolyline(pt, _rail_snap_points.Begin(), _rail_snap_points.Length(), &line) == NULL) ret = HT_NONE; // no match
+	} else if (_current_snap_lock.x != -1) {
+		if (FindBestPolyline(pt, &_current_snap_lock, 1, &line) == NULL) ret = HT_NONE; // no match
+	} else {
+		const LineSnapPoint *snap_point = FindBestPolyline(pt, _rail_snap_points.Begin(), _rail_snap_points.Length(), &line);
+		if (snap_point == NULL) {
+			ret = HT_NONE; // no match
+		} else  {
+			_current_snap_lock = *snap_point;
+			_current_snap_lock.dirs &= (1 << line.first_dir) | (1 << ReverseDir(line.first_dir)); // lock direction
+		}
+	}
+
+	if (ret == HT_NONE) {
+		_thd.selstart.x = -1;
+		_thd.selend.x = -1;
+		_thd.selstart2.x = -1;
+		_thd.selend2.x = -1;
+		_thd.dir2 = HT_DIR_END;
+		return ret;
+	}
+
+	TileIndexDiffC first_dir = TileIndexDiffCByDir(line.first_dir);
+	_thd.selstart.x  = line.start.x;
+	_thd.selstart.y  = line.start.y;
+	_thd.selend.x    = _thd.selstart.x + line.first_len * first_dir.x * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selend.y    = _thd.selstart.y + line.first_len * first_dir.y * (IsDiagonalDirection(line.first_dir) ? TILE_SIZE : TILE_SIZE / 2);
+	_thd.selstart2.x = _thd.selend.x;
+	_thd.selstart2.y = _thd.selend.y;
+	_thd.selstart.x  += first_dir.x;
+	_thd.selstart.y  += first_dir.y;
+	_thd.selend.x    -= first_dir.x;
+	_thd.selend.y    -= first_dir.y;
+	Trackdir seldir = PointDirToTrackdir(_thd.selstart, line.first_dir);
+	_thd.selstart.x  &= ~TILE_UNIT_MASK;
+	_thd.selstart.y  &= ~TILE_UNIT_MASK;
+	ret |= (HighLightStyle)TrackdirToTrack(seldir);
+
+	if (line.second_len != 0) {
+		TileIndexDiffC second_dir = TileIndexDiffCByDir(line.second_dir);
+		_thd.selend2.x   = _thd.selstart2.x + line.second_len * second_dir.x * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selend2.y   = _thd.selstart2.y + line.second_len * second_dir.y * (IsDiagonalDirection(line.second_dir) ? TILE_SIZE : TILE_SIZE / 2);
+		_thd.selstart2.x += second_dir.x;
+		_thd.selstart2.y += second_dir.y;
+		_thd.selend2.x   -= second_dir.x;
+		_thd.selend2.y   -= second_dir.y;
+		Trackdir seldir2 = PointDirToTrackdir(_thd.selstart2, line.second_dir);
+		_thd.selstart2.x &= ~TILE_UNIT_MASK;
+		_thd.selstart2.y &= ~TILE_UNIT_MASK;
+		_thd.dir2 = (HighLightStyle)TrackdirToTrack(seldir2);
+	} else {
+		_thd.dir2 = HT_DIR_END;
+	}
+
+	ShowLengthMeasurement(ret, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y), TCC_HOVER, true);
+	return ret;
 }
 
 /**
@@ -3272,6 +3582,12 @@
 		return;
 	}
 
+	if ((_thd.place_mode & HT_POLY) && _rail_snap_points.Length() > 0) {
+		Point pt = { x, y };
+		_thd.next_drawstyle = CalcPolyrailDrawstyle(pt, true);
+		return;
+	}
+
 	/* Special handling of drag in any (8-way) direction */
 	if (method & (VPM_RAILDIRS | VPM_SIGNALDIRS)) {
 		_thd.selend.x = x;
@@ -3324,27 +3640,12 @@
 				x = sx + Clamp(x - sx, -limit, limit);
 				y = sy + Clamp(y - sy, -limit, limit);
 			}
-			if (_settings_client.gui.measure_tooltip) {
-				TileIndex t0 = TileVirtXY(sx, sy);
-				TileIndex t1 = TileVirtXY(x, y);
-				uint distance = DistanceManhattan(t0, t1) + 1;
-				byte index = 0;
-				uint64 params[2];
-
-				if (distance != 1) {
-					/* With current code passing a HT_LINE style to calculate the height
-					 * difference is enough. However if/when a point-tool is created
-					 * with this method, function should be called with new_style (below)
-					 * instead of HT_LINE | style case HT_POINT is handled specially
-					 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
-					int heightdiff = CalcHeightdiff(HT_LINE | style, 0, t0, t1);
-
-					params[index++] = distance;
-					if (heightdiff != 0) params[index++] = heightdiff;
-				}
-
-				ShowMeasurementTooltips(measure_strings_length[index], index, params);
-			}
+			/* With current code passing a HT_LINE style to calculate the height
+			 * difference is enough. However if/when a point-tool is created
+			 * with this method, function should be called with new_style (below)
+			 * instead of HT_LINE | style case HT_POINT is handled specially
+			 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
+			ShowLengthMeasurement(HT_LINE | style, TileVirtXY(sx, sy), TileVirtXY(x, y));
 			break;
 
 		case VPM_A_B_LINE: { // drag an A to B line
@@ -3479,11 +3780,10 @@
 		return ES_HANDLED;
 	}
 
-	/* while dragging execute the drag procedure of the corresponding window (mostly VpSelectTilesWithMethod() ) */
-	if (_left_button_down) {
-		w->OnPlaceDrag(_thd.select_method, _thd.select_proc, GetTileBelowCursor());
-		return ES_HANDLED;
-	}
+	/* While dragging execute the drag procedure of the corresponding window (mostly VpSelectTilesWithMethod() ).
+	 * Do it even if the button is no longer pressed to make sure that OnPlaceDrag was called at least once. */
+	w->OnPlaceDrag(_thd.select_method, _thd.select_proc, GetTileBelowCursor());
+	if (_left_button_down) return ES_HANDLED;
 
 	/* mouse button released..
 	 * keep the selected tool, but reset it to the original mode. */
@@ -3494,7 +3794,7 @@
 	} else if (_thd.select_method & VPM_SIGNALDIRS) {
 		_thd.place_mode = HT_RECT | others;
 	} else if (_thd.select_method & VPM_RAILDIRS) {
-		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS) ? _thd.next_drawstyle : (HT_RAIL | others);
+		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS ? _thd.next_drawstyle : HT_RAIL) | others;
 	} else {
 		_thd.place_mode = HT_POINT | others;
 	}
@@ -3609,3 +3909,66 @@
 	}
 	assert(_vp_sprite_sorter != NULL);
 }
+
+static LineSnapPoint LineSnapPointAtRailTrackEndpoint(TileIndex tile, DiagDirection exit_dir, bool bidirectional)
+{
+	LineSnapPoint ret;
+	ret.x = (TILE_SIZE / 2) * (uint)(2 * TileX(tile) + TileIndexDiffCByDiagDir(exit_dir).x + 1);
+	ret.y = (TILE_SIZE / 2) * (uint)(2 * TileY(tile) + TileIndexDiffCByDiagDir(exit_dir).y + 1);
+
+	ret.dirs = 0;
+	SetBit(ret.dirs, DiagDirToDir(exit_dir));
+	SetBit(ret.dirs, ChangeDir(DiagDirToDir(exit_dir), DIRDIFF_45LEFT));
+	SetBit(ret.dirs, ChangeDir(DiagDirToDir(exit_dir), DIRDIFF_45RIGHT));
+	if (bidirectional) ret.dirs |= ROR<uint8>(ret.dirs, DIRDIFF_REVERSE);
+
+	return ret;
+}
+
+/**
+ * Store the position of lastly built rail track; for highlighting purposes.
+ *
+ * In "polyline" highlighting mode, the stored end point will be used as a snapping point for new
+ * tracks allowing to place multi-segment polylines.
+ *
+ * @param start_tile         tile where the track starts
+ * @param end_tile           tile where the track ends
+ * @param start_track        track piece on the start_tile
+ * @param bidirectional_exit whether to allow to highlight next track in any direction; otherwise new track will have to fallow the stored one (usefull when placing tunnels and bridges)
+ */
+void StoreRailPlacementEndpoints(TileIndex start_tile, TileIndex end_tile, Track start_track, bool bidirectional_exit)
+{
+	if (start_tile != INVALID_TILE && end_tile != INVALID_TILE) {
+		/* calculate trackdirs at booth ends of the track */
+		Trackdir exit_trackdir_at_start = TrackToTrackdir(start_track);
+		Trackdir exit_trackdir_at_end = ReverseTrackdir(TrackToTrackdir(start_track));
+		if (start_tile != end_tile) { // multi-tile case
+			/* determine proper direction (pointing outside of the track) */
+			uint distance = DistanceManhattan(start_tile, end_tile);
+			if (distance > DistanceManhattan(TileAddByDiagDir(start_tile, TrackdirToExitdir(exit_trackdir_at_start)), end_tile)) {
+				Swap(exit_trackdir_at_start, exit_trackdir_at_end);
+			}
+			/* determine proper track on the end tile - switch between upper/lower or left/right based on the length */
+			if (distance % 2 != 0) exit_trackdir_at_end = NextTrackdir(exit_trackdir_at_end);
+		}
+
+		LineSnapPoint snap_start = LineSnapPointAtRailTrackEndpoint(start_tile, TrackdirToExitdir(exit_trackdir_at_start), bidirectional_exit);
+		LineSnapPoint snap_end = LineSnapPointAtRailTrackEndpoint(end_tile, TrackdirToExitdir(exit_trackdir_at_end), bidirectional_exit);
+		/* Find if we already had these coordinates before. */
+		LineSnapPoint *snap;
+		for (snap = _rail_snap_points.Begin(); snap != _rail_snap_points.End(); snap++) {
+			/* Coordinates found - remove the snap point as it was already used. */
+			if (snap->x == snap_start.x && snap->y == snap_start.y) snap_start.dirs = 0;
+			if (snap->x == snap_end.x && snap->y == snap_end.y) snap_end.dirs = 0;
+		}
+		/* Create new snap point set. */
+		_rail_snap_points.Clear();
+		if (snap_start.dirs != 0) *_rail_snap_points.Append() = snap_start;
+		if (snap_end.dirs != 0) *_rail_snap_points.Append() = snap_end;
+	}
+}
+
+void ClearRailPlacementEndpoints()
+{
+	_rail_snap_points.Clear();
+}
diff -r 06e8776d1dc6 src/widgets/rail_widget.h
--- a/src/widgets/rail_widget.h	Mon Dec 29 16:26:05 2014 +0000
+++ b/src/widgets/rail_widget.h	Mon Dec 29 16:26:13 2014 +0000
@@ -21,6 +21,7 @@
 	WID_RAT_BUILD_EW,       ///< Build rail along the game view X axis.
 	WID_RAT_BUILD_Y,        ///< Build rail along the game grid Y axis.
 	WID_RAT_AUTORAIL,       ///< Autorail tool.
+	WID_RAT_POLYRAIL,       ///< Polyline rail tool.
 	WID_RAT_DEMOLISH,       ///< Destroy something with dynamite!
 	WID_RAT_BUILD_DEPOT,    ///< Build a depot.
 	WID_RAT_BUILD_WAYPOINT, ///< Build a waypoint.
